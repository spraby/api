# Оптимизация поиска первой свободной комбинации вариантов

Дата создания: 2026-01-08

## Описание
Оптимизировать функцию `findNextUnusedCombination` в `lib/utils.ts` для поиска первой свободной комбинации опций продукта без генерации всех возможных комбинаций.

**Текущая проблема:**
- Функция генерирует ВСЕ возможные комбинации через `generateAllOptionCombinations`
- При большом количестве опций и значений это неэффективно (например, 3 опции по 10 значений = 1000 комбинаций)
- Затем проходит по всем комбинациям и ищет первую неиспользованную

**Требуемое решение:**
- Генерировать комбинации "лениво" (lazy evaluation) - по одной
- Проверять каждую сгенерированную комбинацию на использование
- Возвращать первую найденную свободную комбинацию
- Если все комбинации использованы - вернуть `null`

## Чеклист

- [ ] Раздел 1: Анализ текущей реализации
  - [ ] Изучить текущую функцию `findNextUnusedCombination`
  - [ ] Изучить функцию `generateAllOptionCombinations`
  - [ ] Понять логику создания ключей комбинаций через `getVariantOptionsKey`

- [ ] Раздел 2: Реализация оптимизированного алгоритма
  - [ ] Создать функцию генерации следующей комбинации (итеративно)
  - [ ] Использовать подход счетчиков (как в системе счисления с разными основаниями)
  - [ ] Реализовать проверку комбинации на использование внутри цикла генерации
  - [ ] Заменить логику в `findNextUnusedCombination` на новый алгоритм

- [ ] Раздел 3: Тестирование
  - [ ] Проверить работу с пустыми опциями
  - [ ] Проверить работу с одной опцией
  - [ ] Проверить работу с несколькими опциями
  - [ ] Проверить работу когда все комбинации заняты
  - [ ] Убрать console.log если он есть

- [ ] Раздел 4: Проверка кода
  - [ ] Запустить `npm run lint` для проверки кода
  - [ ] Исправить ошибки линтера если есть
  - [ ] Убедиться что код соответствует стандартам проекта

## Технические детали

**Алгоритм "ленивой" генерации комбинаций:**

```typescript
// Пример: Options = [Size: [S, M, L], Color: [Red, Blue]]
// Индексы: [0, 0] -> [S, Red]
// Индексы: [0, 1] -> [S, Blue]
// Индексы: [1, 0] -> [M, Red]
// и т.д.

// Начинаем с [0, 0, 0, ...] (первое значение каждой опции)
// При каждой итерации увеличиваем счетчик как в системе счисления:
// - Увеличиваем последний индекс
// - Если он превысил количество значений опции - обнуляем и переходим к предыдущему
// - Продолжаем пока не найдем свободную комбинацию или не переберем все
```

**Структура данных:**
- `Option[]` - массив опций с их значениями
- `VariantValue[]` - комбинация значений опций
- `Set<string>` - множество ключей занятых комбинаций

**Ожидаемая производительность:**
- Лучший случай: O(1) - первая комбинация свободна
- Средний случай: O(n) где n - количество занятых комбинаций + 1
- Худший случай: O(N) где N - общее количество комбинаций (все заняты)