# Фильтрация категорий по бренду в селекторе на странице продукта

Дата создания: 2026-01-03

## Описание
На странице редактирования продукта в селекторе категорий нужно выводить только те категории, которые привязаны к бренду товара, а не все категории подряд.

## Текущая реализация

**Frontend** (`resources/js/admin/Pages/ProductEdit.tsx`):
```tsx
const { data: categories = [] } = useCategories(product?.brand_id);
```

Уже передается `brand_id`, но нужно проверить, фильтруются ли категории на бэкенде.

## Анализ

### Вопросы для изучения:
1. Как связаны Category и Brand?
2. Есть ли поле `brand_id` в таблице `categories`?
3. Как работает API endpoint для получения категорий?
4. Правильно ли применяется фильтр на бэкенде?

## Найденная проблема

**Корневая причина**: В `CategoryController::index()` была логическая ошибка:
- Применялись ДВА последовательных `whereHas` фильтра:
  1. По переданному `brand_id` (строки 25-29)
  2. По `userBrand->id` для не-админов (строки 35-37)
- Это создавало AND условие, которое могло блокировать результаты

**Решение**: Изменена логика на if-else:
- Для не-админов: ВСЕГДА используется только `userBrand` (Row Level Security)
- Для админов: используется переданный `brand_id`

## Чеклист

- [x] **Раздел 1: Анализ структуры данных**
  - [x] Прочитать миграцию таблицы `categories`
  - [x] Прочитать модель `Category`
  - [x] Прочитать модель `Brand`
  - [x] Определить связь между Brand и Category (many-to-many через brand_category)

- [x] **Раздел 2: Анализ Backend API**
  - [x] Найти контроллер для получения категорий
  - [x] Проверить, применяется ли фильтр по brand_id
  - [x] Определить, что нужно исправить

- [x] **Раздел 3: Исправление Backend**
  - [x] Исправить логику фильтрации в CategoryController
  - [x] Убедиться, что возвращаются только категории бренда

- [x] **Раздел 4: Проверка Frontend**
  - [x] Убедиться, что brand_id правильно передается в useCategories
  - [x] Проверить, что селектор обновляется при изменении продукта

- [x] **Раздел 5: Тестирование и отладка**
  - [x] Найдена проблема с пустой строкой в onValueChange
  - [x] Исправлена проблема
  - [x] Код прошел линтер
  - [ ] Протестировать в браузере

## Выполненные исправления

### 1. Исправлена логика фильтрации в CategoryController (app/Http/Controllers/Api/CategoryController.php)
**Было**: Два последовательных `whereHas` создавали AND условие
**Стало**: if-else структура - для менеджеров используется только userBrand, для админов - переданный brand_id

### 2. Добавлена опция enabled в useCategories (resources/js/admin/Pages/ProductEdit.tsx:41-43)
```tsx
const { data: categories = [] } = useCategories(product?.brand_id, {
  enabled: !!product?.brand_id,
});
```
Это предотвращает преждевременный запрос категорий до загрузки продукта.

### 3. Отображение текущей категории, даже если она не в списке бренда (resources/js/admin/Pages/ProductEdit.tsx:240-244)
```tsx
{product?.category && !categories.find(c => c.id === product.category_id) ? (
  <SelectItem key={product.category.id} value={product.category.id.toString()}>
    {product.category.name} (current)
  </SelectItem>
) : null}
```
Если категория продукта не входит в список категорий бренда, она всё равно отображается с меткой "(current)".

### 4. Исправлена проблема с автоматическим выбором категории (resources/js/admin/Pages/ProductEdit.tsx:261-267)
**Проблема**: Select вызывал `onValueChange("")` с пустой строкой, когда не мог найти option с нужным значением, что приводило к сбросу category_id в 0.

**Решение**: Добавлена проверка на пустую строку:
```tsx
onValueChange={(value) => {
  // Ignore empty string values (happens when Select can't find the option)
  if (value === '') {
    return;
  }
  setFormData({ ...formData, category_id: value === 'none' ? null : Number(value) });
}}
```

## Ожидаемый результат

После выполнения задачи:
1. В селекторе категорий отображаются только категории, привязанные к бренду продукта
2. Категория продукта (если назначена) автоматически выбрана в селекторе
3. Селектор не загружается до получения данных о продукте